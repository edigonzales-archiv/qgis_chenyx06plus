sudo su postgres

createdb chenyx06plus
createlang plpgsql chenyx06plus

psql -d chenyx06plus -f /usr/share/postgresql/8.4/contrib/postgis-1.5/postgis.sql
psql -d chenyx06plus -f /usr/share/postgresql/8.4/contrib/postgis-1.5/spatial_ref_sys.sql

GRANT SELECT ON geometry_columns TO mspublic;
GRANT SELECT ON spatial_ref_sys TO mspublic;
GRANT SELECT ON geography_columns TO mspublic;
GRANT SELECT ON geometry_columns TO av_chenyx06admin;
GRANT SELECT ON spatial_ref_sys TO av_chenyx06admin;
GRANT SELECT ON geography_columns TO av_chenyx06admin;
GRANT SELECT ON geometry_columns TO av_chenyx06user;
GRANT SELECT ON spatial_ref_sys TO av_chenyx06user;
GRANT SELECT ON geography_columns TO av_chenyx06user;

-- Schema: bern

-- DROP SCHEMA bern;

CREATE SCHEMA bern
  AUTHORIZATION av_chenyx06admin;

GRANT USAGE ON SCHEMA bern TO av_chenyx06user;
GRANT USAGE ON SCHEMA bern TO av_chenyx06admin;


shp2pgsql -W latin1 -s 21781 -S -I tsp-chenyx06-lv03.shp tsp-lv03 | psql -d chenyx06plus
shp2pgsql -W latin1 -s 2056 -S -I tsp-chenyx06-lv95.shp tsp-lv95 | psql -d chenyx06plus


CREATE TABLE bern.tsp
(
  ogc_fid serial NOT NULL UNIQUE,
  nummer character varying NOT NULL UNIQUE,
  typ integer,
  the_geom_lv03 geometry,
  the_geom_lv95 geometry,  
  CONSTRAINT tsp_pkey PRIMARY KEY (ogc_fid),
  CONSTRAINT enforce_dims_the_geom_lv03 CHECK (st_ndims(the_geom_lv03) = 2),
  CONSTRAINT enforce_geotype_the_geom_lv03 CHECK (geometrytype(the_geom_lv03) = 'POINT'::text OR the_geom_lv03 IS NULL),
  CONSTRAINT enforce_srid_the_geom_lv03 CHECK (st_srid(the_geom_lv03) = 21781),
  CONSTRAINT enforce_dims_the_geom_lv95 CHECK (st_ndims(the_geom_lv95) = 2),
  CONSTRAINT enforce_geotype_the_geom_lv95 CHECK (geometrytype(the_geom_lv95) = 'POINT'::text OR the_geom_lv95 IS NULL),
  CONSTRAINT enforce_srid_the_geom_lv95 CHECK (st_srid(the_geom_lv95) = 2056)
)
WITH (
  OIDS=FALSE
);
ALTER TABLE bern.tsp OWNER TO av_chenyx06admin;
GRANT SELECT ON bern.tsp TO av_chenyx06user;

CREATE INDEX tsp_the_geom_lv03_gist
  ON bern.tsp
  USING gist
  (the_geom_lv03);

CREATE INDEX tsp_the_geom_lv95_gist
  ON bern.tsp
  USING gist
  (the_geom_lv95); 

CREATE INDEX idx_tsp_nummer
  ON bern.tsp
  USING btree
  (nummer);



INSERT INTO geometry_columns VALUES ('"', 'bern', 'tsp', 'the_geom_lv03', 2, '21781', 'POINT');
INSERT INTO geometry_columns VALUES ('"', 'bern', 'tsp', 'the_geom_lv95', 2, '2056', 'POINT');

INSERT INTO bern.tsp (nummer, typ, the_geom_lv03, the_geom_lv95) 
 SELECT a.nom as nummer, 1 as typ, ST_SnapToGrid(a.the_geom, 0.001) as the_geom_lv03, ST_SnapToGrid(b.the_geom, 0.001) as the_geom_lv95
 FROM "tsp-lv03" as a, "tsp-lv95" as b
 WHERE a.nom = b.nom



-- Dreiecke einlesen und in eine Tabelle mergen:

shp2pgsql -W latin1 -s 21781 -S -I chenyx06-lv03.shp dreiecke_lv03 | psql -d chenyx06plus
shp2pgsql -W latin1 -s 2056 -S -I chenyx06-lv95.shp dreiecke_lv95 | psql -d chenyx06plus


ALTER TABLE dreiecke_lv03  ADD CONSTRAINT enforce_triangle_the_geom CHECK(st_npoints(the_geom)= 4); 




-- Constraint fuer Dreieck liegt auf TSP
-- Schema muss händisch angepasst werden. -> kann man das irgendie anders machen?

CREATE OR REPLACE FUNCTION bern.triangle_on_tsp(geometry)
  RETURNS integer AS
$BODY$
SELECT count(*)::integer
FROM
(
 SELECT 1 as ogc_fid, ST_Intersection(ST_SnapToGrid(b.the_geom, 0.001), ST_SnapToGrid(a.the_geom_lv03, 0.001)) as the_geom
 FROM bern.tsp as a,
 (
  SELECT ST_Collect(geom) as the_geom
  FROM
  (
   SELECT (ST_DumpPoints($1)).geom
  ) as a
 ) as b
  WHERE a.the_geom_lv03 && b.the_geom
) as c
WHERE geometrytype(the_geom) = 'POINT'

$BODY$
  LANGUAGE 'sql' IMMUTABLE
  COST 100;

-- Diese Funktion lässt NULL geometrien zu (wegen zweiter geomtriespalte nötig)
CREATE OR REPLACE FUNCTION bern.triangle_on_tsp(triangle geometry) RETURNS integer AS $$
DECLARE
 count_row RECORD;
BEGIN
 IF triangle IS NULL
 THEN
  RETURN 3;
 ELSE
  SELECT count(*)::integer as count INTO count_row
  FROM
  (
   SELECT 1 as ogc_fid, ST_Intersection(ST_SnapToGrid(b.the_geom, 0.001), ST_SnapToGrid(a.the_geom_lv03, 0.001)) as the_geom
   FROM bern.tsp as a,
   (
    SELECT ST_Collect(geom) as the_geom
    FROM
    (
     SELECT (ST_DumpPoints(triangle)).geom
    ) as a
   ) as b
    WHERE a.the_geom_lv03 && b.the_geom
  ) as c
  WHERE geometrytype(the_geom) = 'POINT';
  RETURN count_row.count;
  
 END IF;
END;
$$ LANGUAGE plpgsql;
  






ALTER TABLE dreiecke_lv03 ADD CONSTRAINT enforce_triangle_on_tsp_the_geom CHECK(bern.triangle_on_tsp(the_geom) = 3); 


-- richtige Dreieckstabelle anlegen

CREATE TABLE bern.dreiecke 
(
  ogc_fid serial NOT NULL,
  nummer character varying NOT NULL UNIQUE,
  typ integer,
  the_geom_lv03 geometry,
  the_geom_lv95 geometry,
  CONSTRAINT dreiecke_pkey PRIMARY KEY (ogc_fid),
  CONSTRAINT enforce_dims_the_geom_lv03 CHECK (st_ndims(the_geom_lv03) = 2),
  CONSTRAINT enforce_geotype_the_geom_lv03 CHECK (geometrytype(the_geom_lv03) = 'POLYGON'::text OR the_geom_lv03 IS NULL),
  CONSTRAINT enforce_srid_the_geom_lv03 CHECK (st_srid(the_geom_lv03) = 21781),
  CONSTRAINT enforce_triangle_the_geom_lv03 CHECK (st_npoints(the_geom_lv03) = 4),
  CONSTRAINT enforce_triangle_on_tsp_the_geom_lv03 CHECK(bern.triangle_on_tsp(the_geom_lv03) = 3),
  CONSTRAINT enforce_dims_the_geom_lv95 CHECK (st_ndims(the_geom_lv95) = 2),
  CONSTRAINT enforce_geotype_the_geom_lv95 CHECK (geometrytype(the_geom_lv95) = 'POLYGON'::text OR the_geom_lv03 IS NULL),
  CONSTRAINT enforce_srid_the_geom_lv95 CHECK (st_srid(the_geom_lv95) = 2056),
  CONSTRAINT enforce_triangle_the_geom_lv95 CHECK (st_npoints(the_geom_lv95) = 4),
  CONSTRAINT enforce_triangle_on_tsp_the_geom_lv95 CHECK(bern.triangle_on_tsp(the_geom_lv95) = 3)
)
WITH (
  OIDS=FALSE
);
ALTER TABLE bern.dreiecke OWNER TO av_chenyx06admin;
GRANT SELECT ON bern.dreiecke TO av_chenyx06user;

CREATE INDEX dreiecke_the_geom_lv03_gist
  ON bern.dreiecke
  USING gist
  (the_geom_lv03);

 CREATE INDEX dreiecke_the_geom_lv95_gist
  ON bern.dreiecke
  USING gist
  (the_geom_lv95); 

INSERT INTO geometry_columns VALUES ('"', 'bern', 'dreiecke', 'the_geom_lv03', 2, '21781', 'POLYGON');
INSERT INTO geometry_columns VALUES ('"', 'bern', 'dreiecke', 'the_geom_lv95', 2, '2056', 'POLYGON');


INSERT INTO bern.dreiecke (nummer, typ, the_geom_lv03) 
 SELECT num as nummer, 1 as typ, ST_SnapToGrid(the_geom, 0.001) as the_geom_lv03
 FROM dreiecke_lv03  



--- das wäre so circa für die lookup table -> nein, aber für die liste aller punkte mit geomtrie
 SELECT 1 as ogc_fid, a.nummer, ST_Intersection(ST_SnapToGrid(b.the_geom, 0.001), ST_SnapToGrid(a.the_geom_lv03, 0.001)) as the_geom
 FROM bern.tsp as a,
 (
  SELECT ST_Collect(geom) as the_geom
  FROM
  (
   SELECT (ST_DumpPoints(the_geom_lv03)).geom
   FROM bern.dreiecke
   WHERE nummer = 'AG0002'
  ) as a
 ) as b
  WHERE a.the_geom_lv03 && b.the_geom

--- das wäre was für lookup table, 
-- zwei varianten: distinct oder aus boundary den letzten punkt löschen
-- ist so sichergestellt, dass gegenuhrzeigersinn?  was passiert bei 
-- intersection. sieht jedenfalls nicht allzu schlecht aus.

SELECT tsp_nummer, dreieck_nummer
FROM
(
 SELECT a.nummer as tsp_nummer, b.nummer as dreieck_nummer, ST_Intersection(ST_SnapToGrid(b.the_geom, 0.001), ST_SnapToGrid(a.the_geom_lv03, 0.001)) as the_geom
 FROM bern.tsp as a,
 (
   SELECT nummer, (ST_DumpPoints(the_geom)).geom as the_geom
   FROM
   (
     SELECT nummer, ST_RemovePoint(ST_Boundary(ST_Reverse(ST_ForceRHR(the_geom_lv03))),3) as the_geom FROM ch.dreiecke ORDER BY nummer LIMIT 10
   ) as c
 ) as b
 WHERE a.the_geom_lv03 && b.the_geom
) as d


 SELECT a.nummer as tsp_nummer, b.nummer as dreieck_nummer, ST_Intersection(ST_SnapToGrid(b.the_geom, 0.001), ST_SnapToGrid(a.the_geom_lv03, 0.001)) as the_geom
 FROM bern.tsp as a,
 (
  SELECT DISTINCT (geom) as the_geom, nummer
  FROM
  (
   SELECT nummer, (ST_DumpPoints(the_geom_lv03)).geom
   FROM
   (
     SELECT * FROM ch.dreiecke LIMIT 1
   ) as c
  ) as d
 ) as b
 WHERE a.the_geom_lv03 && b.the_geom
 ORDER BY dreieck_nummer


-- Lookuptable abfüllen.
INSERT INTO ch.dreiecke_tsp (tsp_nummer, dreieck_nummer) 
SELECT tsp_nummer, dreieck_nummer
FROM
(
 SELECT a.nummer as tsp_nummer, b.nummer as dreieck_nummer, ST_Intersection(ST_SnapToGrid(b.the_geom, 0.001), ST_SnapToGrid(a.the_geom_lv03, 0.001)) as the_geom
 FROM bern.tsp as a,
 (
   SELECT nummer, (ST_DumpPoints(the_geom)).geom as the_geom
   FROM
   (
     SELECT nummer, ST_RemovePoint(ST_Boundary(ST_Reverse(ST_ForceRHR(the_geom_lv03))),3) as the_geom FROM ch.dreiecke ORDER BY nummer 
   ) as c
 ) as b
 WHERE a.the_geom_lv03 && b.the_geom
) as d


/*=================================================================================================*/
/*=================================================================================================*/
/*=================================================================================================*/


DROP TABLE wasseramt.dreiecke_tsp_v2;

CREATE TABLE wasseramt.dreiecke_tsp_v2
(
  ogc_fid serial NOT NULL,
  dreieck_nummer character varying NOT NULL,
  tsp_nummer_1 character varying,
  tsp_nummer_2 character varying,
  tsp_nummer_3 character varying,
  
  CONSTRAINT dreiecke_tsp_v2_pkey PRIMARY KEY (ogc_fid)
)
WITH (
  OIDS=FALSE
);
ALTER TABLE wasseramt.dreiecke_tsp_v2 OWNER TO av_chenyx06admin;
GRANT ALL ON TABLE wasseramt.dreiecke_tsp_v2 TO av_chenyx06admin;
GRANT SELECT ON TABLE wasseramt.dreiecke_tsp_v2 TO av_chenyx06user;

CREATE INDEX idx_dreiecke_tsp_v2_dreieck_nummer
  ON wasseramt.dreiecke_tsp_v2
  USING btree
  (dreieck_nummer);

CREATE INDEX idx_dreiecke_tsp_v2_tsp_nummer_1
  ON wasseramt.dreiecke_tsp_v2
  USING btree
  (tsp_nummer_1);

CREATE INDEX idx_dreiecke_tsp_v2_tsp_nummer_2
  ON wasseramt.dreiecke_tsp_v2
  USING btree
  (tsp_nummer_2);

CREATE INDEX idx_dreiecke_tsp_v2_tsp_nummer_3
  ON wasseramt.dreiecke_tsp_v2
  USING btree
  (tsp_nummer_3);


DELETE FROM wasseramt.dreieck_tsp_v2;

-- fuer einmal alles importieren:
INSERT INTO wasseramt.dreiecke_tsp_v2 (dreieck_nummer, tsp_nummer_1)
  SELECT n.nummer as dreieck_nummer, m.nummer as tsp_nummer 
  FROM wasseramt.tsp_lv03 m,
  (
   SELECT nummer, ST_PointN(ST_Boundary(ST_Reverse(ST_ForceRHR(the_geom))),1) as the_geom 
   FROM wasseramt.dreiecke_lv03_bearbeitung ORDER BY nummer
  ) n
  WHERE n.the_geom && m.the_geom
  AND ST_Intersects(ST_SnapToGrid(n.the_geom, 0.001), ST_SnapToGrid(m.the_geom, 0.001)) 


UPDATE wasseramt.dreiecke_tsp_v2 
SET tsp_nummer_2 = 
(
  SELECT m.nummer as tsp_nummer 
  FROM wasseramt.tsp_lv03 m,
  (
   SELECT nummer, ST_PointN(ST_Boundary(ST_Reverse(ST_ForceRHR(the_geom))),2) as the_geom 
   FROM wasseramt.dreiecke_lv03_bearbeitung 
   WHERE wasseramt.dreiecke_tsp_v2.dreieck_nummer = wasseramt.dreiecke_lv03_bearbeitung.nummer   
   ORDER BY nummer
  ) n
  WHERE n.the_geom && m.the_geom
  AND ST_Intersects(ST_SnapToGrid(n.the_geom, 0.001), ST_SnapToGrid(m.the_geom, 0.001)) 
); 


UPDATE wasseramt.dreiecke_tsp_v2 
SET tsp_nummer_3 = 
(
  SELECT m.nummer as tsp_nummer 
  FROM wasseramt.tsp_lv03 m,
  (
   SELECT nummer, ST_PointN(ST_Boundary(ST_Reverse(ST_ForceRHR(the_geom))),3) as the_geom 
   FROM wasseramt.dreiecke_lv03_bearbeitung 
   WHERE wasseramt.dreiecke_tsp_v2.dreieck_nummer = wasseramt.dreiecke_lv03_bearbeitung.nummer   
   ORDER BY nummer
  ) n
  WHERE n.the_geom && m.the_geom
  AND ST_Intersects(ST_SnapToGrid(n.the_geom, 0.001), ST_SnapToGrid(m.the_geom, 0.001)) 
); 



-- Erst nach dem ersten Import die NOT NULL constraints hinzufügen:
ALTER TABLE wasseramt.dreiecke_tsp_v2
ALTER COLUMN tsp_nummer_1 SET NOT NULL,
ALTER COLUMN tsp_nummer_2 SET NOT NULL,
ALTER COLUMN tsp_nummer_3 SET NOT NULL;



